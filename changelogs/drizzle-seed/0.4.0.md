## Features

- ### Added support for MS SQL database

```ts
import { int, mssqlTable, text } from "drizzle-orm/mssql-core";
import { drizzle } from "drizzle-orm/node-mssql";
import { seed } from "drizzle-seed";

const users = mssqlTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();
```

- ### Added support for CockroachDB database

```ts
import { cockroachTable, int4, text } from "drizzle-orm/cockroach-core";
import { drizzle } from "drizzle-orm/cockroach";
import { seed } from "drizzle-seed";

const users = cockroachTable("users", {
  id: int4().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();
```

- ### Added support for SingleStore database

```ts
import { int, singlestoreTable, text } from "drizzle-orm/singlestore-core";
import { drizzle } from "drizzle-orm/singlestore";
import { seed } from "drizzle-seed";

const users = singlestoreTable("users", {
  id: int().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();
```

- ### Added new generator `bitString` for CockroachDB and PostgreSQL `bit` type.

#### Generates bit strings based on specified parameters:

- param `isUnique` - property that controls if generated values gonna be unique or not;

- param `arraySize` - number of elements in each one-dimensional array (If specified, arrays will be generated);

- param `dimensions` - desired length of each bit string (e.g., `dimensions = 3` produces values like `'010'`).

  Defaults to the value of the database column bit-length

```ts
await seed(db, { bitStringTable: schema.bitStringTable }).refine((funcs) => ({
  bitStringTable: {
    count,
    columns: {
      bit: funcs.bitString({
        dimensions: 12,
        isUnique: true,
      }),
    },
  },
}));
```

- ### Added new generator `inet` for CockroachDB and PostgreSQL `inet` type.

#### Generates ip addresses based on specified parameters:

- param `isUnique` - property that controls if generated values gonna be unique or not;

- param `arraySize` - number of elements in each one-dimensional array (If specified, arrays will be generated);

- param `ipAddress` - type of IP address to generate — either "ipv4" or "ipv6";

  Defaults to `'ipv4'`

- param `includeCidr` - determines whether generated IPs include a CIDR suffix.

  Defaults to `true`

```ts
await seed(db, { inetTable: schema.inetTable }).refine((funcs) => ({
  inetTable: {
    count,
    columns: {
      inet: funcs.inet({
        ipAddress: "ipv4",
        includeCidr: true,
        isUnique: true,
      }),
    },
  },
}));
```

- ### Added new generator `geometry` for CockroachDB and PostgreSQL `geometry` type.

#### Generates PostGIS geometry objects based on the given parameters:

- param `isUnique` - property that controls if generated values gonna be unique or not;

- param `arraySize` - number of elements in each one-dimensional array (If specified, arrays will be generated);

- param `type` - geometry type to generate; currently only `'point'` is supported;

  Defaults to `'point'`

- param `srid` - Spatial Reference System Identifier: determines what type of point will be generated - either `4326` or `3857`;

  Defaults to `4326`

- param `decimalPlaces` - number of decimal places for points when `srid` is `4326` (e.g., `decimalPlaces = 3` produces values like `'point(30.723 46.482)'`).

  Defaults to `6`

```ts
await seed(db, { geometryTable: schema.geometryTable }).refine((funcs) => ({
  geometryTable: {
    count,
    columns: {
      geometryPointTuple: funcs.geometry({
        type: "point",
        srid: 4326,
        decimalPlaces: 5,
        isUnique: true,
      }),
    },
  },
}));
```

- ### Added new generator `vector` for CockroachDB, PostgreSQL and SingleStore `vector` type.

#### Generates vectors based on the provided parameters:

- param `isUnique` - property that controls if generated values gonna be unique or not;

- param `arraySize` - number of elements in each one-dimensional array (If specified, arrays will be generated);

- param `decimalPlaces` - number of decimal places for each vector element (e.g., `decimalPlaces = 3` produces values like `1.123`);

  Defaults to `2`

- param `dimensions` - number of elements in each generated vector (e.g., `dimensions = 3` produces values like `[1,2,3]`);

  Defaults to the value of the database column's dimensions

- param `minValue` - minimum allowed value for each vector element;

  Defaults to `-1000`

- param `maxValue` - maximum allowed value for each vector element.

  Defaults to `1000`

```ts
await seed(db, { vectorTable: schema.vectorTable }).refine((funcs) => ({
  vectorTable: {
    count,
    columns: {
      vector: funcs.vector({
        decimalPlaces: 5,
        dimensions: 12,
        minValue: -100,
        maxValue: 100,
        isUnique: true,
      }),
    },
  },
}));
```

- ### Added support for composite unique constraints

  #### Example:

  Table with a composite unique constraint:

  ```ts
  import { integer, pgTable, text, unique } from "drizzle-orm/pg-core";

  const composite = pgTable(
    "composite_example",
    {
      id: integer("id").notNull(),
      name: text("name").notNull(),
    },
    (t) => [unique("custom_name").on(t.id, t.name)]
  );
  ```

  Seeding script:

  ```ts
  await seed(db, { composite: composite }, { count: 16 }).refine((funcs) => ({
    composite: {
      columns: {
        id: funcs.valuesFromArray({ values: [0, 1, 2, 3] }),
        name: funcs.valuesFromArray({ values: ["a", "b", "c", "d"] }),
      },
    },
  }));
  ```

  #### Limitations:

  - Seeding is not supported when two composite unique constraints share a column:
    ```ts
    const composite = pgTable(
      "composite_example",
      {
        id: integer("id").notNull(),
        name: text("name").notNull(),
        slug: text("slug").notNull(),
      },
      (t) => [
        unique("custom_name").on(t.id, t.name),
        unique("custom_name1").on(t.name, t.slug),
      ]
    );
    ```
    This is allowed, however, if one of the constraints is a single-column unique constraint:
    ```ts
    unique("custom_name1").on(t.name);
    ```
  - You can’t use a generator that doesn’t expose an `isUnique` option in its config, unless it’s one of the always-unique generators: `intPrimaryKey`, `email`, `phoneNumber`, or `uuid`.

## Bug Fixes

- fixed type error in `seed` and `reset` functions when using a drizzle db instance that was created with a schema in `DrizzleConfig`.

  https://github.com/drizzle-team/drizzle-orm/issues/4435

## Breaking changes

### Hash generating function was changed and upgraded to v3

```ts
await seed(db, { table }).refine((f) => ({
  table: {
    columns: {
      // all generators will output different values compared to the previous version, even with the same seed number.
      column1: f.interval({ isUnique: true }),
    }
  }
}))
```

**Reason for upgrade**

The previous version of the hash generating function generated different hashes depending on whether Bun or Node.js was used, and hashes also varied across versions of Node.js.

The new hash generating function will generate the same hash regardless of the version of Node.js or Bun, resulting in deterministic data generation across all versions.

**Usage**
```ts
await seed(db, schema);
// or explicit
await seed(db, schema, { version: '3' });
```

**Switch to the old version**

The previous version of hash generating function is v1.
```ts
await seed(db, schema, { version: '1' });
```
To use the v2 generators while maintaining the v1 hash generating function:
```ts
await seed(db, schema, { version: '2' });
```
