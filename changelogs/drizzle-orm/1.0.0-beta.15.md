## Changes

We've stopped maintaining separate validator packages (e.g., `drizzle-zod`, `drizzle-valibot`) and moved them into the `drizzle-orm` repo. This consolidates everything into a single package and eliminates the need to manage separate peer dependencies and versioning.

All packages are now available via `drizzle-orm` imports:

- `drizzle-zod` -> `drizzle-orm/zod`
- `drizzle-valibot` -> `drizzle-orm/valibot`
- `drizzle-typebox` -> `drizzle-orm/typebox-legacy` (using `@sinclair/typebox`)
- `drizzle-typebox` -> `drizzle-orm/typebox` (using `typebox`)
- `drizzle-arktype` -> `drizzle-orm/arktype`

You can still use the old packages, but we recommend removing them and importing directly from `drizzle-orm`. There should be no breaking changes and a simple import change should work

## New Features

New validation package is available: `drizzle-orm/effect-schema`

```ts
import * as p from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema, createUpdateSchema } from 'drizzle-orm/effect-schema';
import { Schema } from 'effect';

const users = p.pgTable('users', {
  id: p.serial().primaryKey(),
  name: p.text().notNull(),
  email: p.text().notNull(),
  role: p.text({ enum: ['admin', 'user'] }).notNull(),
  createdAt: p.timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const UserInsert = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const UserUpdate = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const UserSelect = createSelectSchema(users);

// Overriding the fields
const UserInsert = createInsertSchema(users, {
  role: Schema.String,
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const UserInsert = createInsertSchema(users, {
  id: (schema) => schema.pipe(Schema.greaterThanOrEqualTo(0)),
  role: Schema.String,
});

// Usage

const program = Effect.gen(function*() {
  const parsedUser = yield* Schema.validate(UserInsert)({
    name: 'John Doe',
    email: 'johndoe@test.com',
    role: 'admin',
  });
});
```

## Improvements

- Fixed sqlite select not allowing SQL.Aliased in `.orderBy(...)`, `.groupBy(...)`

This is now allowed:

```ts
const sq1 = db.$with('sq1').as((qb) =>
        qb.select({
          aliased: sql`count(*)`.mapWith(Number).as('alias'),
        }).from(users)
      );
      const sq2 = db.$with('sq2').as((qb) =>
        qb.select({
          aliased: sql`sum(${users.id})`.mapWith(Number).as('alias'),
        }).from(users)
      );

      const result = await db.with(sq1, sq2).select({
        count: sq1.aliased,
        sum: sq2.aliased,
      }).from(sq1).crossJoin(sq2);
```

- Made `name` argument in `.prepare(name)` optional in `Gel`, `Postgres`, `Cockroach` dialects (generated automatically if not passed)