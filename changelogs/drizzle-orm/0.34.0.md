// Libsql and Sqlite migration updates

SQLite generate statements updates. Starting from this release, we won't generate comments like this:

```sql
      '/*\n SQLite does not support "Changing existing column type" out of the box, we do not generate automatic migration for that, so it has to be done manually'
      + '\n Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php'
      + '\n                  https://www.sqlite.org/lang_altertable.html'
      + '\n                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3'
      + "\n\n Due to that we don't generate migration automatically and it has to be done manually"
      + '\n*/'
```

We will generate a set of statements instead and you will decide if it's good to make data moving statements instead. Here is an example of generated sql file you'll get now:

```sql
```

LibSQL generate statements updates. As long as libsql support more alter statements than SQLite we can generate more statements without recreating you schema and moving all the data, which can be potentially dangeourose for production envs

LibSQL and Turso will now get a separate dialect in drizzle config file, means, that we will evolve Turso and LibSQL separately from SQLite and will try to support as much features Turso/LibSQL would have as possible

Breaking change! All the users, who wants to get max from Turso and LibSQL DDL statements, shouls remove `driver: turso` from drizzle.config and add `dialect: turso` instead

With updated LibSQL migrartion staretegy you would have a possibility to:

- **Change Data Type**: You can set a new data type for existing columns.
- **Set and Drop Default Values**: You can add or remove default values for existing columns.
- **Set and Drop Not Null Constraint**: You can add or remov the `NOT NULL` constraint on existing columns.
- **Add References to Existing Columns**: You can add foreign key references to existing columns.


### Code Example:

```sql
PRAGMA foreign_keys=OFF; 

CREATE TABLE `__new_table` (
    `id` integer PRIMARY KEY AUTOINCREMENT NOT NULL,
    `name` text NOT NULL
);

INSERT INTO `__new_table`("id", "name") SELECT "id", "name" FROM `table`;

DROP TABLE `table`;

ALTER TABLE `__new_table` RENAME TO `table`;

PRAGMA foreign_keys=ON;
```

### LIMITATIONS

- Dropping or altering index will cause table recreation

This is because LibSQL does not support dropping this type of index:

```sql
CREATE TABLE `users` (
	`id` integer NOT NULL,
	`name` integer,
	`age` integer PRIMARY KEY NOT NULL
	FOREIGN KEY (`name`) REFERENCES `users1`("id") ON UPDATE no action ON DELETE no action
);
```

- If the table has indexes, altering columns will cause table recreation.
  Drizzle-Kit will drop those indexes, modify the columns, and then recreate the indexes.
- Adding or dropping `composite foreign keys` is not supported and will cause table recreation.

### NOTES:

- You can create reference on any column type, but if you want to insert values than primary column should have unique index or primary key

```sql
CREATE TABLE parent(a PRIMARY KEY, b UNIQUE, c, d, e, f);
CREATE UNIQUE INDEX i1 ON parent(c, d);
CREATE INDEX i2 ON parent(e);
CREATE UNIQUE INDEX i3 ON parent(f COLLATE nocase);

CREATE TABLE child1(f, g REFERENCES parent(a));                        -- Ok
CREATE TABLE child2(h, i REFERENCES parent(b));                        -- Ok
CREATE TABLE child3(j, k, FOREIGN KEY(j, k) REFERENCES parent(c, d));  -- Ok
CREATE TABLE child4(l, m REFERENCES parent(e));                        -- Error!
CREATE TABLE child5(n, o REFERENCES parent(f));                        -- Error!
CREATE TABLE child6(p, q, FOREIGN KEY(p, q) REFERENCES parent(b, c));  -- Error!
CREATE TABLE child7(r REFERENCES parent(c));                           -- Error!
```

> NOTE: The foreign key for table *child5* is an error because even though the parent key column has a unique index, the index uses a different collating sequence

See more: https://www.sqlite.org/foreignkeys.html

// monodriver

before on example with node-postgres

```ts
const client = new Pool({ url: '' });
drizzle(client, { logger: true });
```

will become

```ts
await drizzle('', { client: '', logger: true })
await drizzle('', { client: {}, logger: true })
```

> Note that first example with client is still available and not deprecated. You ca use it, if you don't want to await drizzle object. New way of defining drizzle is done to make it easiser to import from 1 place and get an autocmplete with all the possible clients

// db count feature

to count entities in table you would need to do this
```ts
const res = await db.select({ count: sql`count(*)` }).from(users);
const count = res[0].count;
```

a new api will look like
```ts
// how many users are in the database
const count: number = await db.$count(users);

// how many users with the name "Dan" are in the database
const count: number = await db.$count(users, eq(name, "Dan"));
```

This can also work as a subquery and inside relational queries
```ts
const users = await db.select({
    ...users,
    postsCount: db.$count(posts, eq(posts.authorId, users.id))
});

const users = await db.query.users.findMany({
    extras: {
        postsCount: db.$count(posts, eq(posts.authorId, users.id))
    }
})
```
