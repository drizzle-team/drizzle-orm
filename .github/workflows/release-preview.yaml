name: Internal Release (preview)

on: workflow_dispatch

env:
  GITHUB_TOKEN: ${{ secrets.GCP_GOWISH_GKE_GITHUB_ACCESS_TOKEN }}

jobs:
  release:
    permissions: write-all
    strategy:
      fail-fast: false
      matrix:
        package:
          - drizzle-orm
          - drizzle-kit
          - drizzle-zod
          - drizzle-seed
          - drizzle-typebox
          - drizzle-valibot
          - eslint-plugin-drizzle
    runs-on: ubuntu-20.04
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '18.18'
          registry-url: 'https://npm.pkg.github.com'
          scope: '@dotcom-dev'

      - uses: pnpm/action-setup@v3
        name: Install pnpm
        id: pnpm-install
        with:
          version: latest
          run_install: false

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - uses: actions/cache@v4
        name: Setup pnpm cache
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        run: pnpm install

      - name: Check preconditions
        id: checks
        shell: bash
        working-directory: ${{ matrix.package }}
        run: |
          # Prepare package name with scope for GitHub registry
          package_name="@dotcom-dev/${{ matrix.package }}"
          
          # Get version from package.json and create RC version
          original_version="$(jq -r .version package.json)"
          rc_version="${original_version}-rc.$(date +'%Y%m%d%H%M%S')"
          
          echo "Original version: $original_version"
          echo "RC version: $rc_version"
          
          # Update package.json with RC version
          jq --arg version "$rc_version" '.version = $version' package.json > package.json.tmp
          mv package.json.tmp package.json
          
          changelogPath=$(node -e "console.log(require('path').resolve('..', 'changelogs', '${{ matrix.package }}', '$original_version.md'))")
          if [[ ! -f "$changelogPath" ]]; then
            echo "::warning::Changelog for version $original_version not found: $changelogPath"
            echo "This is a release candidate build - proceeding without changelog"
            changelogPath=""
          fi

          {
            echo "original_version=$original_version"
            echo "version=$rc_version"
            echo "has_new_release=true"
            echo "changelog_path=$changelogPath"
            echo "package_name=$package_name"
          } >> $GITHUB_OUTPUT

      - name: Update package.json for GitHub registry
        if: steps.checks.outputs.has_new_release == 'true'
        working-directory: ${{ matrix.package }}
        shell: bash
        run: |
          # Update package.json to use GitHub registry name format
          jq '.name = "@dotcom-dev/${{ matrix.package }}"' package.json > package.json.tmp
          mv package.json.tmp package.json
          
          # Add publishConfig to ensure it goes to GitHub registry with next tag
          jq '.publishConfig = {"registry": "https://npm.pkg.github.com", "access": "restricted", "tag": "next"}' package.json > package.json.tmp
          mv package.json.tmp package.json

      - name: Build
        if: steps.checks.outputs.has_new_release == 'true'
        run: |
          (
            cd drizzle-orm
            pnpm prisma generate --schema src/prisma/schema.prisma
          )
          pnpm build

      - name: Pack
        if: steps.checks.outputs.has_new_release == 'true'
        working-directory: ${{ matrix.package }}
        shell: bash
        run: |
          npm run pack

      - name: Run @arethetypeswrong/cli
        if: steps.checks.outputs.has_new_release == 'true'
        working-directory: ${{ matrix.package }}
        shell: bash
        run: |
          pnpm attw package.tgz

      - name: Publish to GitHub registry
        if: steps.checks.outputs.has_new_release == 'true'
        working-directory: ${{ matrix.package }}
        shell: bash
        env:
          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          version="${{ steps.checks.outputs.version }}"
          package_name="${{ steps.checks.outputs.package_name }}"

          echo "Publishing $package_name@$version to GitHub registry with tag 'next'"
          npm run publish -- --tag next

          echo "GitHub registry (next): \`+ $package_name@$version\`" >> $GITHUB_STEP_SUMMARY

      - name: Create GitHub release for ORM package
        uses: actions/github-script@v6
        if: matrix.package == 'drizzle-orm' && steps.checks.outputs.has_new_release == 'true'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require("fs");
              const path = require("path");

              const version = "${{ steps.checks.outputs.version }}";
              const originalVersion = "${{ steps.checks.outputs.original_version }}";
              
              let releaseBody = `# Release Candidate for v${originalVersion}\n\nThis is a pre-release build for testing purposes.`;
              
              const changelogPath = "${{ steps.checks.outputs.changelog_path }}";
              if (changelogPath) {
                try {
                  const changelog = fs.readFileSync(changelogPath, "utf8");
                  releaseBody += `\n\n## Upcoming Changes\n\n${changelog}`;
                } catch (e) {
                  console.log(`Could not read changelog: ${e.message}`);
                }
              }

              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: `rc-${version}`,
                name: `Release Candidate ${version}`,
                body: releaseBody,
                prerelease: true
              });

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: `${{ matrix.package }}-${version}-dist.tgz`,
                data: fs.readFileSync(path.resolve("${{ matrix.package }}", "package.tgz")),
              });
            } catch (e) {
              core.setFailed(e.message);
            }

      - name: Create GitHub release for KIT package
        uses: actions/github-script@v6
        if: matrix.package == 'drizzle-kit' && steps.checks.outputs.has_new_release == 'true'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const fs = require("fs");
              const path = require("path");

              const version = "${{ steps.checks.outputs.version }}";
              const originalVersion = "${{ steps.checks.outputs.original_version }}";
              
              let releaseBody = `# Release Candidate for v${originalVersion}\n\nThis is a pre-release build for testing purposes.`;
              
              const changelogPath = "${{ steps.checks.outputs.changelog_path }}";
              if (changelogPath) {
                try {
                  const changelog = fs.readFileSync(changelogPath, "utf8");
                  releaseBody += `\n\n## Upcoming Changes\n\n${changelog}`;
                } catch (e) {
                  console.log(`Could not read changelog: ${e.message}`);
                }
              }

              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: `rc-drizzle-kit@${version}`,
                name: `Release Candidate drizzle-kit@${version}`,
                body: releaseBody,
                prerelease: true
              });

              await github.rest.repos.uploadReleaseAsset({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.data.id,
                name: `${{ matrix.package }}-${version}-dist.tgz`,
                data: fs.readFileSync(path.resolve("${{ matrix.package }}", "package.tgz")),
              });
            } catch (e) {
              core.setFailed(e.message);
            }