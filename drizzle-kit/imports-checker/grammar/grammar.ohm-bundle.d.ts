// AUTOGENERATED FILE
// This file was generated from grammar.ohm by `ohm generateBundles`.

import { BaseActionDict, Grammar, IterationNode, Node, NonterminalNode, Semantics, TerminalNode } from 'ohm-js';

export interface JSImportsActionDict<T> extends BaseActionDict<T> {
	JSImports?: (this: NonterminalNode, arg0: IterationNode, arg1: IterationNode) => T;
	Expr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	ImportExpr_From?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: TerminalNode,
		arg3: NonterminalNode,
	) => T;
	ImportExpr_NoFrom?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	ImportExpr?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	Rest?: (this: NonterminalNode, arg0: IterationNode) => T;
	ImportInner_Type?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: TerminalNode,
		arg2: NonterminalNode,
		arg3: IterationNode,
		arg4: TerminalNode,
	) => T;
	ImportInner_Types?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: IterationNode,
		arg3: TerminalNode,
	) => T;
	ImportInner_Extended?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: IterationNode,
		arg3: TerminalNode,
	) => T;
	ImportInner_Mixed?: (
		this: NonterminalNode,
		arg0: NonterminalNode,
		arg1: IterationNode,
		arg2: IterationNode,
		arg3: IterationNode,
		arg4: IterationNode,
		arg5: IterationNode,
		arg6: IterationNode,
	) => T;
	ImportInner_All?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: IterationNode) => T;
	ImportInner_Default?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
	ImportInner?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	ImportExtendedSelection?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	ImportExtendedSelectionTypes?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	ImportExtendedSelectionTypeless?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	Import?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode, arg2: IterationNode) => T;
	TypeImport?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: IterationNode,
		arg3: IterationNode,
	) => T;
	identifier?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
	quote?: (this: NonterminalNode, arg0: TerminalNode) => T;
	notQuote?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	importSource?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
	lineTerminator?: (this: NonterminalNode, arg0: TerminalNode) => T;
	lineTerminatorSequence?: (this: NonterminalNode, arg0: TerminalNode) => T;
	comment?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	multiLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
	singleLineComment?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode) => T;
	stringLiteral?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
	doubleStringCharacter_NonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	doubleStringCharacter_Escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	doubleStringCharacter_LineContinuation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	doubleStringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	singleStringCharacter_NonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	singleStringCharacter_Escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	singleStringCharacter_LineContinuation?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	singleStringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	templateStringCharacter_NonEscaped?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	templateStringCharacter_Escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	templateStringCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	lineContinuation?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	escapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	characterEscapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	singleEscapeCharacter?: (this: NonterminalNode, arg0: TerminalNode) => T;
	nonEscapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	escapeCharacter?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
	octalEscapeSequence_Whole?: (
		this: NonterminalNode,
		arg0: NonterminalNode,
		arg1: NonterminalNode,
		arg2: NonterminalNode,
	) => T;
	octalEscapeSequence_EightTimesfourToSeven?: (
		this: NonterminalNode,
		arg0: NonterminalNode,
		arg1: NonterminalNode,
	) => T;
	octalEscapeSequence_EightTimesZeroToThree?: (
		this: NonterminalNode,
		arg0: NonterminalNode,
		arg1: NonterminalNode,
	) => T;
	octalEscapeSequence_Octal?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	octalEscapeSequence?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	hexEscapeSequence?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode, arg2: NonterminalNode) => T;
	unicodeEscapeSequence?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: NonterminalNode,
		arg3: NonterminalNode,
		arg4: NonterminalNode,
	) => T;
	zeroToThree?: (this: NonterminalNode, arg0: TerminalNode) => T;
	fourToSeven?: (this: NonterminalNode, arg0: TerminalNode) => T;
	decimalDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
	nonZeroDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
	octalDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
	regularExpressionLiteral?: (
		this: NonterminalNode,
		arg0: TerminalNode,
		arg1: NonterminalNode,
		arg2: TerminalNode,
		arg3: NonterminalNode,
	) => T;
	regularExpressionBody?: (this: NonterminalNode, arg0: NonterminalNode, arg1: IterationNode) => T;
	regularExpressionFirstChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	regularExpressionChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	regularExpressionBackslashSequence?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	regularExpressionNonTerminator?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	regularExpressionClass?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
	regularExpressionClassChar?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	regularExpressionFlags?: (this: NonterminalNode, arg0: IterationNode) => T;
	multiLineCommentNoNL?: (this: NonterminalNode, arg0: TerminalNode, arg1: IterationNode, arg2: TerminalNode) => T;
	identifierStart_escaped?: (this: NonterminalNode, arg0: TerminalNode, arg1: NonterminalNode) => T;
	identifierStart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
	identifierPart?: (this: NonterminalNode, arg0: NonterminalNode | TerminalNode) => T;
	letter?: (this: NonterminalNode, arg0: NonterminalNode) => T;
	unicodeCategoryNl?: (this: NonterminalNode, arg0: TerminalNode) => T;
	unicodeDigit?: (this: NonterminalNode, arg0: TerminalNode) => T;
	unicodeCombiningMark?: (this: NonterminalNode, arg0: TerminalNode) => T;
	unicodeConnectorPunctuation?: (this: NonterminalNode, arg0: TerminalNode) => T;
	unicodeSpaceSeparator?: (this: NonterminalNode, arg0: TerminalNode) => T;
}

export interface JSImportsSemantics extends Semantics {
	addOperation<T>(name: string, actionDict: JSImportsActionDict<T>): this;
	extendOperation<T>(name: string, actionDict: JSImportsActionDict<T>): this;
	addAttribute<T>(name: string, actionDict: JSImportsActionDict<T>): this;
	extendAttribute<T>(name: string, actionDict: JSImportsActionDict<T>): this;
}

export interface JSImportsGrammar extends Grammar {
	createSemantics(): JSImportsSemantics;
	extendSemantics(superSemantics: JSImportsSemantics): JSImportsSemantics;
}

declare const grammar: JSImportsGrammar;
export default grammar;
