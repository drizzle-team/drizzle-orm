import { type MigratorInitFailResponse, readMigrationFiles } from '~/migrator.ts';
import type { AnyRelations, EmptyRelations } from '~/relations.ts';
import { sql } from '~/sql/sql.ts';
import type { XataHttpDatabase } from './driver.ts';

export interface MigrationConfig {
	migrationsFolder: string;
	migrationsTable?: string;
	/** @internal */
	init?: boolean;
}

/**
 * This function reads migrationFolder and execute each unapplied migration and mark it as executed in database
 *
 * NOTE: The Xata HTTP driver does not support transactions. This means that if any part of a migration fails,
 * no rollback will be executed. Currently, you will need to handle unsuccessful migration yourself.
 * @param db - drizzle db instance
 * @param config - path to migration folder generated by drizzle-kit
 */ export async function migrate<
	TSchema extends Record<string, unknown>,
	TRelations extends AnyRelations = EmptyRelations,
>(
	db: XataHttpDatabase<TSchema, TRelations>,
	config: MigrationConfig,
): Promise<void | MigratorInitFailResponse> {
	const migrations = readMigrationFiles(config);
	const migrationsTable = config.migrationsTable ?? '__drizzle_migrations';
	const migrationTableCreate = sql`
		CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsTable)} (
			id SERIAL PRIMARY KEY,
			hash text NOT NULL,
			created_at bigint
		)
	`;
	await db.session.execute(migrationTableCreate);

	const dbMigrations = await db.session.all<{
		id: number;
		hash: string;
		created_at: string;
	}>(
		sql`select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`,
	);

	if (typeof config === 'object' && config.init) {
		if (dbMigrations.length) {
			return { exitCode: 'databaseMigrations' as const };
		}

		if (migrations.length > 1) {
			return { exitCode: 'localMigrations' as const };
		}

		const [migration] = migrations;

		if (!migration) return;

		await db.session.execute(
			sql`insert into ${
				sql.identifier(migrationsTable)
			} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`,
		);

		return;
	}

	const lastDbMigration = dbMigrations[0];
	for await (const migration of migrations) {
		if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
			for (const stmt of migration.sql) {
				await db.session.execute(sql.raw(stmt));
			}

			await db.session.execute(
				sql`insert into ${
					sql.identifier(migrationsTable)
				} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`,
			);
		}
	}
}
